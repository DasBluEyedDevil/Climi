---
phase: 12-v2-gap-closure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - mcp-bridge/lib/mcp-tools.sh
  - mcp-bridge/lib/mcp-core.sh
  - hooks/lib/hooks-common.sh
autonomous: true
must_haves:
  truths:
    - MCP tools accept auto_model parameter to enable intelligent model selection
    - When auto_model is true, MCP tools call model selector to choose K2 vs K2.5
    - Model selector receives task description and file paths from tool arguments
    - Selected model is passed to mcp_call_kimi for actual invocation
    - Hooks pass auto_model: true in JSON-RPC requests to enable selection
    - Backward compatibility maintained (auto_model defaults to false)
  artifacts:
    - path: mcp-bridge/lib/mcp-tools.sh
      provides: "Tool handlers with auto_model support"
      min_lines: 50
      contains: "auto_model"
    - path: mcp-bridge/lib/mcp-core.sh
      provides: "Model selection helper function"
      min_lines: 30
      contains: "mcp_select_model"
    - path: hooks/lib/hooks-common.sh
      provides: "Hooks with auto_model enabled"
      min_lines: 20
      contains: "auto_model"
  key_links:
    - from: "mcp_tool_analyze"
      to: "kimi-model-selector.sh"
      via: "mcp_select_model helper"
      pattern: "kimi-model-selector.sh.*--task"
    - from: "hooks_run_analysis"
      to: "mcp_tool_analyze"
      via: "JSON-RPC with auto_model"
      pattern: "auto_model.*true"
---

<objective>
Close the integration gap between Phase 10 (Model Selection) and Phase 8 (MCP Tools) by wiring the intelligent K2 vs K2.5 model selector into MCP tool handlers.

Purpose: Enable end-to-end intelligent model selection so hooks automatically choose the right model (K2 for routine tasks, K2.5 for creative/UI) based on file types and task classification.

Output: Modified MCP tools that accept auto_model parameter and call model selector when enabled; updated hooks that pass auto_model: true.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/v2.0-MILESTONE-AUDIT.md

@mcp-bridge/lib/mcp-tools.sh
@mcp-bridge/lib/mcp-core.sh
@skills/kimi-model-selector.sh
@hooks/lib/hooks-common.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add model selection helper to mcp-core.sh</name>
  <files>mcp-bridge/lib/mcp-core.sh</files>
  <action>
Add a new helper function `mcp_select_model()` to mcp-core.sh that:
1. Accepts task description and file paths as arguments
2. Locates and executes skills/kimi-model-selector.sh with proper arguments
3. Parses JSON output to extract selected model
4. Returns "k2" or "k2.5" (falls back to "k2" on error)

Function signature:
```bash
mcp_select_model() {
    local task="$1"
    local files="$2"  # JSON array string
    # ...implementation...
}
```

Search paths for model selector (in order):
1. "${MCP_ROOT}/../skills/kimi-model-selector.sh"
2. "${HOME}/.local/share/kimi-workflow/skills/kimi-model-selector.sh"
3. "kimi-model-selector.sh" (PATH)

Use jq to parse the JSON output and extract `.model` field.
</action>
  <verify>grep -q "mcp_select_model" mcp-bridge/lib/mcp-core.sh && echo "Helper added"</verify>
  <done>mcp_select_model function exists in mcp-core.sh and returns correct model when called with test arguments</done>
</task>

<task type="auto">
  <name>Task 2: Extend MCP tool inputSchema with auto_model parameter</name>
  <files>mcp-bridge/lib/mcp-tools.sh</files>
  <action>
Modify `mcp_get_tool_definitions()` to add auto_model parameter to all 4 tools (kimi_analyze, kimi_implement, kimi_refactor, kimi_verify):

Add to each tool's inputSchema.properties:
```json
auto_model: {
    type: "boolean",
    description: "Enable automatic model selection (K2 for routine, K2.5 for creative)",
    default: false
}
```

This maintains backward compatibility - existing calls without auto_model will use static config.
</action>
  <verify>grep -q '"auto_model"' mcp-bridge/lib/mcp-tools.sh && echo "auto_model parameter added"</verify>
  <done>All 4 tool definitions include auto_model parameter with boolean type, description, and default false</done>
</task>

<task type="auto">
  <name>Task 3: Modify tool handlers to use model selection when auto_model enabled</name>
  <files>mcp-bridge/lib/mcp-tools.sh</files>
  <action>
Modify all 4 tool handlers (mcp_tool_analyze, mcp_tool_implement, mcp_tool_refactor, mcp_tool_verify) to:

1. Extract auto_model parameter from arguments using jq:
   ```bash
   local auto_model
   auto_model=$(echo "$arguments" | jq -r '.auto_model // false')
   ```

2. When calling Kimi, check auto_model and select appropriate model source:
   ```bash
   local model
   if [[ "$auto_model" == "true" ]]; then
       # Build task description from prompt
       local task="$prompt"
       model=$(mcp_select_model "$task" "$files")
   else
       model=$(mcp_config_model)
   fi
   ```

3. Pass selected model to mcp_call_kimi as before

Apply this pattern to all 4 tool handlers. Keep existing logic for building prompts and handling files.
</action>
  <verify>grep -A5 "auto_model" mcp-bridge/lib/mcp-tools.sh | grep -q "mcp_select_model" && echo "Handlers updated"</verify>
  <done>All 4 tool handlers check auto_model parameter and call mcp_select_model when enabled, otherwise use mcp_config_model</done>
</task>

<task type="auto">
  <name>Task 4: Update hooks to pass auto_model: true in JSON-RPC requests</name>
  <files>hooks/lib/hooks-common.sh</files>
  <action>
Modify `hooks_run_analysis()` and `hooks_run_implement()` to include auto_model: true in the JSON-RPC request:

For hooks_run_analysis (around line 221-237):
```bash
request=$(jq -n \
    --arg prompt "$prompt" \
    --argjson files "$files" \
    --arg context "$context" \
    '{
        jsonrpc: "2.0",
        id: "hooks-analysis",
        method: "tools/call",
        params: {
            name: "kimi_analyze",
            arguments: {
                prompt: $prompt,
                files: $files,
                context: $context,
                auto_model: true
            }
        }
    }')
```

For hooks_run_implement (around line 287-302):
```bash
request=$(jq -n \
    --arg prompt "$prompt" \
    --argjson files "$files" \
    '{
        jsonrpc: "2.0",
        id: "hooks-implement",
        method: "tools/call",
        params: {
            name: "kimi_implement",
            arguments: {
                prompt: $prompt,
                files: $files,
                auto_model: true
            }
        }
    }')
```

This enables automatic model selection for all hook-triggered MCP calls.
</action>
  <verify>grep -q '"auto_model": true' hooks/lib/hooks-common.sh && echo "Hooks updated"</verify>
  <done>Both hooks_run_analysis and hooks_run_implement include auto_model: true in their JSON-RPC requests</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Syntax check all modified files:**
   ```bash
   bash -n mcp-bridge/lib/mcp-core.sh
   bash -n mcp-bridge/lib/mcp-tools.sh
   bash -n hooks/lib/hooks-common.sh
   ```

2. **Test model selection helper:**
   ```bash
   source mcp-bridge/lib/mcp-core.sh
   result=$(mcp_select_model "refactor python code" '["src/main.py"]')
   [[ "$result" == "k2" ]] && echo "PASS: Python selects K2"
   
   result=$(mcp_select_model "create React component" '["src/App.tsx"]')
   [[ "$result" == "k2.5" ]] && echo "PASS: TSX selects K2.5"
   ```

3. **Verify tool definitions include auto_model:**
   ```bash
   source mcp-bridge/lib/mcp-tools.sh
   defs=$(mcp_get_tool_definitions)
   echo "$defs" | jq '.tools[].inputSchema.properties.auto_model'
   # Should show auto_model definition for all 4 tools
   ```

4. **Integration flow verification:**
   - Hook detects .tsx files â†’ triggers analysis
   - hooks_run_analysis sends auto_model: true
   - mcp_tool_analyze extracts auto_model
   - Calls mcp_select_model with task and files
   - Returns K2.5 for UI component
   - Kimi invoked with K2.5 model
</verification>

<success_criteria>
- [ ] mcp_select_model helper exists in mcp-core.sh and returns correct model
- [ ] All 4 MCP tool definitions include auto_model parameter (default: false)
- [ ] All 4 MCP tool handlers check auto_model and call mcp_select_model when true
- [ ] hooks_run_analysis includes auto_model: true in JSON-RPC request
- [ ] hooks_run_implement includes auto_model: true in JSON-RPC request
- [ ] Backward compatibility: calls without auto_model still use mcp_config_model
- [ ] All modified files pass bash syntax check
- [ ] Integration flow works end-to-end (test with model selector)
</success_criteria>

<output>
After completion, create `.planning/phases/12-v2-gap-closure/12-01-SUMMARY.md`

Update `.planning/v2.0-MILESTONE-AUDIT.md` to mark gap as resolved.
</output>
