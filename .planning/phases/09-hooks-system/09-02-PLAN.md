---
phase: 09-hooks-system
plan: 02
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - hooks/lib/hooks-common.sh
  - hooks/hooks/pre-commit
  - hooks/hooks/post-checkout
  - hooks/hooks/pre-push
autonomous: true

must_haves:
  truths:
    - "Pre-commit hook runs before commits and can analyze staged files"
    - "Post-checkout hook runs after branch switches and analyzes changed files"
    - "Pre-push hook runs before push and can run tests"
    - "All hooks respect configuration (enablement, timeout, dry-run)"
    - "All hooks support bypass via environment variable"
    - "Hooks handle errors gracefully without blocking git operations (configurable)"
  artifacts:
    - path: "hooks/lib/hooks-common.sh"
      provides: "Common functions shared by all hooks"
      exports: ["hooks_init", "hooks_check_bypass", "hooks_get_changed_files", "hooks_run_analysis"]
    - path: "hooks/hooks/pre-commit"
      provides: "Pre-commit hook script"
      pattern: "executable bash script"
    - path: "hooks/hooks/post-checkout"
      provides: "Post-checkout hook script"
      pattern: "executable bash script"
    - path: "hooks/hooks/pre-push"
      provides: "Pre-push hook script"
      pattern: "executable bash script"
  key_links:
    - from: "hooks/hooks/pre-commit"
      to: "hooks/lib/hooks-common.sh"
      via: "source command"
      pattern: 'source.*hooks-common\.sh'
    - from: "hooks/hooks/pre-commit"
      to: "hooks/lib/hooks-config.sh"
      via: "source command"
      pattern: 'source.*hooks-config\.sh'
    - from: "hooks/hooks/*"
      to: "bin/kimi-mcp"
      via: "MCP tool invocation"
      pattern: 'kimi-mcp.*call|kimi analyze'
---

<objective>
Create the three core git hook scripts (pre-commit, post-checkout, pre-push) and a shared library of common functions.

Purpose: Implement the actual hook scripts that will auto-delegate coding tasks to Kimi at key git workflow points.
Output: Three executable hook scripts in hooks/hooks/ and a shared library in hooks/lib/.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-hooks-system/09-01-SUMMARY.md (after completion)
@mcp-bridge/lib/mcp-tools.sh

From 09-RESEARCH.md:
- Hook script structure: check bypass → load config → check enabled → get changed files → run logic
- Pre-commit: stash unstaged → analyze staged → apply fixes → restore stash
- Post-checkout: get diff between refs → analyze changes → show summary
- Pre-push: run tests → analyze failures → suggest fixes
- All hooks need timeout protection and graceful error handling
- Set KIMI_HOOKS_RUNNING=1 to prevent recursion
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create common hooks library</name>
  <files>hooks/lib/hooks-common.sh</files>
  <action>
Create hooks/lib/hooks-common.sh with shared functions for all hooks:

1. hooks_init(hook_type) - Initialize hook:
   - Check KIMI_HOOKS_SKIP env var (bypass)
   - Check KIMI_HOOKS_RUNNING (prevent recursion)
   - Set KIMI_HOOKS_RUNNING=1
   - Load configuration via hooks_config_load
   - Check if this hook type is enabled
   - Return 0 if should proceed, 1 if should skip

2. hooks_check_bypass() - Check bypass conditions:
   - Check KIMI_HOOKS_SKIP environment variable
   - Check git config kimi.hooks.skip
   - Return 0 if bypassed, 1 if should run

3. hooks_get_changed_files(hook_type) - Get relevant files:
   - pre-commit: git diff --cached --name-only --diff-filter=ACM
   - post-checkout: git diff --name-only $old_ref $new_ref
   - pre-push: git diff --name-only @{push} HEAD (or similar)
   - Filter by file_patterns from config
   - Return list of files or empty string

4. hooks_has_matching_files(files) - Check if any files match patterns:
   - Use file_patterns from config
   - Return 0 if match found, 1 otherwise

5. hooks_run_analysis(prompt, files, context) - Run Kimi analysis:
   - Use kimi-mcp tool call analyze (from Phase 8)
   - Apply timeout from config
   - Handle dry-run mode
   - Return analysis result or empty on timeout

6. hooks_run_implement(prompt, files) - Run Kimi implement:
   - Use kimi-mcp tool call implement
   - Apply timeout
   - Return result

7. hooks_cleanup() - Cleanup function:
   - Unset KIMI_HOOKS_RUNNING
   - Restore any stashed changes if needed

8. Logging functions:
   - hooks_log_info(msg) - echo to stderr
   - hooks_log_error(msg) - echo to stderr
   - hooks_log_debug(msg) - only if KIMI_HOOKS_DEBUG=1

Include proper error handling and trap for cleanup on exit.
  </action>
  <verify>bash -n hooks/lib/hooks-common.sh && echo "Syntax OK"</verify>
  <done>Common library exists with all shared functions and passes syntax check</done>
</task>

<task type="auto">
  <name>Task 2: Create pre-commit hook</name>
  <files>hooks/hooks/pre-commit</files>
  <action>
Create hooks/hooks/pre-commit as an executable bash script:

#!/bin/bash
# Pre-commit hook: Analyze staged files and offer auto-fixes

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HOOKS_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

source "$HOOKS_ROOT/lib/hooks-config.sh"
source "$HOOKS_ROOT/lib/hooks-common.sh"

# Initialize hook
if ! hooks_init "pre-commit"; then
    exit 0
fi

# Get staged files
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM)
if [[ -z "$STAGED_FILES" ]]; then
    hooks_log_info "No staged files to check"
    exit 0
fi

# Filter to matching patterns
MATCHING_FILES=$(hooks_filter_files "$STAGED_FILES")
if [[ -z "$MATCHING_FILES" ]]; then
    hooks_log_info "No matching files to analyze"
    exit 0
fi

hooks_log_info "Kimi is analyzing staged files..."

# Build file list for MCP
FILE_JSON=$(echo "$MATCHING_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')

# Run analysis
PROMPT="Analyze these staged files for issues (linting, formatting, type errors, bugs). List any issues found and suggest fixes."
RESULT=$(hooks_run_analysis "$PROMPT" "$FILE_JSON" "")

if [[ -z "$RESULT" ]]; then
    hooks_log_info "No issues found or analysis timed out"
    exit 0
fi

echo ""
echo "Kimi found potential issues:"
echo "$RESULT"
echo ""

# Check if auto-fix is enabled
if hooks_config_auto_fix "pre-commit"; then
    hooks_log_info "Auto-fix is enabled. Attempting fixes..."
    
    # Stash unstaged changes to avoid conflicts
    STASHED=false
    if ! git diff --quiet; then
        git stash push -q -m "pre-commit auto-fix stash"
        STASHED=true
    fi
    
    # Run implement to fix issues
    FIX_PROMPT="Fix the issues found in these files: $RESULT"
    hooks_run_implement "$FIX_PROMPT" "$FILE_JSON"
    
    # Stage the fixes
    echo "$MATCHING_FILES" | xargs git add
    
    # Restore stashed changes
    if [[ "$STASHED" == "true" ]]; then
        git stash pop -q
    fi
    
    hooks_log_info "Fixes applied and staged"
else
    # Interactive mode: ask user
    echo "Run with auto-fix enabled to apply fixes automatically."
    echo "Or use: git commit --no-verify to skip hooks"
fi

exit 0

Make the script executable (chmod +x).
  </action>
  <verify>bash -n hooks/hooks/pre-commit && test -x hooks/hooks/pre-commit && echo "Executable and syntax OK"</verify>
  <done>Pre-commit hook exists, is executable, and passes syntax check</done>
</task>

<task type="auto">
  <name>Task 3: Create post-checkout hook</name>
  <files>hooks/hooks/post-checkout</files>
  <action>
Create hooks/hooks/post-checkout as an executable bash script:

#!/bin/bash
# Post-checkout hook: Analyze files changed between branches

PREV_REF="$1"
NEW_REF="$2"
BRANCH_SWITCH="$3"  # 1 if branch switch, 0 if file checkout

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HOOKS_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

source "$HOOKS_ROOT/lib/hooks-config.sh"
source "$HOOKS_ROOT/lib/hooks-common.sh"

# Initialize hook
if ! hooks_init "post-checkout"; then
    exit 0
fi

# Skip if not a branch switch (just file checkout)
if [[ "$BRANCH_SWITCH" != "1" ]]; then
    hooks_log_debug "Not a branch switch, skipping"
    exit 0
fi

# Get files changed between refs
CHANGED_FILES=$(git diff --name-only "$PREV_REF" "$NEW_REF")
if [[ -z "$CHANGED_FILES" ]]; then
    hooks_log_info "No files changed between branches"
    exit 0
fi

# Filter to matching patterns
MATCHING_FILES=$(hooks_filter_files "$CHANGED_FILES")
if [[ -z "$MATCHING_FILES" ]]; then
    hooks_log_info "No matching files to analyze"
    exit 0
fi

# Check max_files limit
MAX_FILES=$(hooks_config_get "hooks.post-checkout.max_files")
FILE_COUNT=$(echo "$MATCHING_FILES" | wc -l)
if [[ "$FILE_COUNT" -gt "$MAX_FILES" ]]; then
    hooks_log_info "Too many files changed ($FILE_COUNT > $MAX_FILES), skipping analysis"
    exit 0
fi

hooks_log_info "Kimi is analyzing branch changes..."

# Build file list for MCP
FILE_JSON=$(echo "$MATCHING_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')

# Get branch names for context
PREV_BRANCH=$(git name-rev --name-only "$PREV_REF" 2>/dev/null || echo "$PREV_REF")
NEW_BRANCH=$(git name-rev --name-only "$NEW_REF" 2>/dev/null || echo "$NEW_REF")

# Run analysis
PROMPT="Summarize the changes in these files between branches. Highlight important changes, potential conflicts, and context the developer should know."
CONTEXT="Switched from $PREV_BRANCH to $NEW_BRANCH"
RESULT=$(hooks_run_analysis "$PROMPT" "$FILE_JSON" "$CONTEXT")

if [[ -n "$RESULT" ]]; then
    echo ""
    echo "=== Branch Change Summary ==="
    echo "From: $PREV_BRANCH"
    echo "To: $NEW_BRANCH"
    echo ""
    echo "$RESULT"
    echo "==========================="
    echo ""
fi

exit 0

Make the script executable.
  </action>
  <verify>bash -n hooks/hooks/post-checkout && test -x hooks/hooks/post-checkout && echo "Executable and syntax OK"</verify>
  <done>Post-checkout hook exists, is executable, and passes syntax check</done>
</task>

<task type="auto">
  <name>Task 4: Create pre-push hook</name>
  <files>hooks/hooks/pre-push</files>
  <action>
Create hooks/hooks/pre-push as an executable bash script:

#!/bin/bash
# Pre-push hook: Run tests and analyze failures

REMOTE="$1"
REMOTE_URL="$2"

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
HOOKS_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

source "$HOOKS_ROOT/lib/hooks-config.sh"
source "$HOOKS_ROOT/lib/hooks-common.sh"

# Initialize hook
if ! hooks_init "pre-push"; then
    exit 0
fi

# Check if test running is enabled
if ! hooks_config_get "hooks.pre-push.run_tests"; then
    hooks_log_info "Test running disabled in config"
    exit 0
fi

# Get test command
TEST_CMD=$(hooks_config_get "hooks.pre-push.test_command")
if [[ -z "$TEST_CMD" ]]; then
    hooks_log_debug "No test command configured"
    exit 0
fi

hooks_log_info "Running tests: $TEST_CMD"

# Run tests and capture output
TEST_OUTPUT=$(mktemp)
if eval "$TEST_CMD" > "$TEST_OUTPUT" 2>&1; then
    hooks_log_info "Tests passed!"
    rm -f "$TEST_OUTPUT"
    exit 0
fi

# Tests failed
TEST_EXIT=$?
hooks_log_error "Tests failed (exit code: $TEST_EXIT)"

# Check if auto-fix is enabled
if ! hooks_config_auto_fix "pre-push"; then
    echo ""
    echo "Test output:"
    cat "$TEST_OUTPUT"
    echo ""
    echo "Run with auto_fix enabled to attempt automatic fixes."
    rm -f "$TEST_OUTPUT"
    exit 1
fi

# Get files being pushed
PUSH_FILES=$(git diff --name-only @{push} HEAD 2>/dev/null || git diff --name-only origin/HEAD HEAD 2>/dev/null)
if [[ -z "$PUSH_FILES" ]]; then
    hooks_log_info "Could not determine files being pushed"
    rm -f "$TEST_OUTPUT"
    exit 1
fi

MATCHING_FILES=$(hooks_filter_files "$PUSH_FILES")
if [[ -z "$MATCHING_FILES" ]]; then
    hooks_log_info "No matching files to analyze"
    rm -f "$TEST_OUTPUT"
    exit 1
fi

hooks_log_info "Asking Kimi to analyze test failures..."

# Build file list and context
FILE_JSON=$(echo "$MATCHING_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
TEST_CONTENT=$(cat "$TEST_OUTPUT")
CONTEXT="Test command: $TEST_CMD\n\nTest output:\n$TEST_CONTENT"

# Run analysis
PROMPT="These tests failed. Analyze the test output and the relevant source files to identify the root cause and suggest fixes."
RESULT=$(hooks_run_analysis "$PROMPT" "$FILE_JSON" "$CONTEXT")

if [[ -n "$RESULT" ]]; then
    echo ""
    echo "=== Kimi's Analysis ==="
    echo "$RESULT"
    echo "======================="
    echo ""
    
    if hooks_config_is_dry_run; then
        hooks_log_info "Dry-run mode: not applying fixes"
    else
        hooks_log_info "Attempting to apply fixes..."
        FIX_PROMPT="Fix the test failures: $RESULT"
        hooks_run_implement "$FIX_PROMPT" "$FILE_JSON"
        hooks_log_info "Fixes applied. Please review and re-run tests."
    fi
fi

rm -f "$TEST_OUTPUT"
exit 1  # Still fail push so user can review

Make the script executable.
  </action>
  <verify>bash -n hooks/hooks/pre-push && test -x hooks/hooks/pre-push && echo "Executable and syntax OK"</verify>
  <done>Pre-push hook exists, is executable, and passes syntax check</done>
</task>

</tasks>

<verification>
1. All hook scripts are executable: `ls -la hooks/hooks/`
2. All scripts pass syntax check: `bash -n hooks/hooks/*`
3. Common library loads without errors
4. Each hook script has proper shebang and sources libraries
</verification>

<success_criteria>
- hooks/lib/hooks-common.sh provides shared functions for all hooks
- hooks/hooks/pre-commit is executable and implements staged file analysis
- hooks/hooks/post-checkout is executable and implements branch change analysis
- hooks/hooks/pre-push is executable and implements test failure analysis
- All hooks support: bypass, timeout, dry-run, configuration
- HOOK-01, HOOK-02, HOOK-03 requirements met
</success_criteria>

<output>
After completion, create `.planning/phases/09-hooks-system/09-02-SUMMARY.md`
</output>
