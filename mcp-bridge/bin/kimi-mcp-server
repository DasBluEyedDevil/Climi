#!/usr/bin/env bash
#
# Kimi MCP Server - Main Executable
#
# Purpose: Main MCP server entry point that MCP clients execute.
#          Implements the full MCP server lifecycle with JSON-RPC message loop.
#
# Usage:
#   ./kimi-mcp-server
#
#   The server reads JSON-RPC requests from stdin and writes responses to stdout.
#   All logging goes to stderr to avoid protocol corruption.
#
# Protocol: MCP 2025-11-25 (stdio transport)

set -euo pipefail

# ============================================================================
# Environment Setup
# ============================================================================

# Determine script location and set MCP_BRIDGE_ROOT
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
MCP_BRIDGE_ROOT="$(dirname "$SCRIPT_DIR")"
export MCP_BRIDGE_ROOT

# Source all required libraries
source "${MCP_BRIDGE_ROOT}/lib/mcp-errors.sh"
source "${MCP_BRIDGE_ROOT}/lib/mcp-core.sh"
source "${MCP_BRIDGE_ROOT}/lib/config.sh"
source "${MCP_BRIDGE_ROOT}/lib/file-reader.sh"
source "${MCP_BRIDGE_ROOT}/lib/mcp-tools.sh"

# ============================================================================
# Logging Functions
# ============================================================================

# Log info message to stderr
log_info() {
    local msg="$1"
    echo "[INFO] $msg" >&2
}

# Log error message to stderr
log_error() {
    local msg="$1"
    echo "[ERROR] $msg" >&2
}

# ============================================================================
# Signal Handlers
# ============================================================================

# Handle clean shutdown
cleanup() {
    log_info "Kimi MCP Server shutting down..."
    exit 0
}

# Set up signal handlers
trap cleanup SIGINT SIGTERM

# ============================================================================
# Method Handlers
# ============================================================================

# Handle initialize method
# Arguments:
#   $1 - Request ID
#   $2 - Params JSON
handle_initialize() {
    local id="$1"
    local params="${2:-{}}"
    
    # Extract client protocol version (optional, for logging)
    local client_version
    client_version=$(echo "$params" | jq -r '.protocolVersion // "unknown"')
    log_info "Initialize request from client protocol version: $client_version"
    
    # Send InitializeResult with server capabilities
    mcp_send_initialize_result "$id"
}

# Handle tools/list method
# Arguments:
#   $1 - Request ID
handle_tools_list() {
    local id="$1"
    
    log_info "Handling tools/list request"
    
    # Get tool definitions and extract just the tools array
    local tools_json
    tools_json=$(mcp_get_tool_definitions | jq -c '.tools')
    
    # Send tools list response
    mcp_send_tools_list "$id" "$tools_json"
}

# Handle tools/call method
# Arguments:
#   $1 - Request ID
#   $2 - Params JSON
handle_tools_call() {
    local id="$1"
    local params="${2:-{}}"
    
    log_info "Handling tools/call request"
    
    # Extract tool name and arguments
    local tool_name
    tool_name=$(echo "$params" | jq -r '.name // empty')
    local arguments
    arguments=$(echo "$params" | jq -c '.arguments // {}')
    
    # Validate tool name
    if [[ -z "$tool_name" || "$tool_name" == "null" ]]; then
        mcp_send_response "$id" "Missing required parameter: name" "true"
        return
    fi
    
    log_info "Dispatching to tool: $tool_name"
    
    # Dispatch to appropriate handler
    case "$tool_name" in
        "kimi_analyze")
            mcp_tool_analyze "$arguments" "$id"
            ;;
        "kimi_implement")
            mcp_tool_implement "$arguments" "$id"
            ;;
        "kimi_refactor")
            mcp_tool_refactor "$arguments" "$id"
            ;;
        "kimi_verify")
            mcp_tool_verify "$arguments" "$id"
            ;;
        *)
            # Unknown tool - send tool error (not protocol error)
            mcp_send_response "$id" "Unknown tool: $tool_name" "true"
            ;;
    esac
}

# ============================================================================
# Main Message Loop
# ============================================================================

main() {
    # Load configuration
    if ! mcp_config_load; then
        log_error "Failed to load configuration"
        exit 1
    fi
    
    log_info "Kimi MCP Server starting..."
    log_info "Protocol version: $MCP_PROTOCOL_VERSION"
    log_info "Server: $MCP_SERVER_NAME v$MCP_SERVER_VERSION"
    
    # Main message loop - read JSON-RPC requests from stdin
    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue
        
        # Validate JSON
        if ! echo "$line" | jq empty 2>/dev/null; then
            log_error "Parse error: Invalid JSON received"
            mcp_error_parse "" "Parse error: Invalid JSON"
            continue
        fi
        
        # Parse the request
        local parsed
        parsed=$(mcp_parse_request "$line")
        
        # Extract fields
        local id
        id=$(echo "$parsed" | jq -r '.id // empty')
        local method
        method=$(echo "$parsed" | jq -r '.method // empty')
        local params
        params=$(echo "$parsed" | jq -c '.params // {}')
        
        # Validate method field
        if [[ -z "$method" ]]; then
            log_error "Invalid request: missing method field"
            mcp_error_invalid_request "$id" "Invalid Request: missing method"
            continue
        fi
        
        log_info "Received request: method=$method, id=$id"
        
        # Dispatch to handler
        case "$method" in
            "initialize")
                handle_initialize "$id" "$params"
                ;;
            "tools/list")
                handle_tools_list "$id"
                ;;
            "tools/call")
                handle_tools_call "$id" "$params"
                ;;
            "notifications/initialized")
                # Notification, no response needed
                log_info "Received initialized notification"
                ;;
            *)
                log_error "Method not found: $method"
                mcp_error_method_not_found "$id" "$method"
                ;;
        esac
    done
    
    # stdin closed - clean shutdown
    cleanup
}

# Run main function
main "$@"
